\subsection{Idée Originale : Bison} Nous avons tout d'abord pensé à developper notre agent conversationnel sous la forme d'un interpréteur, en utilisant les technologies Lex et Yacc vues dans le cours d'Intro à la Compilation. Cet interpréteur aurait analysé la phrase entrée par l'utilisateur à l'aide des règles de la grammaire française, puis construit une réponse appropriée à l'aide de ces mêmes règles.Une telle analyse aurait nécessité de distinguer tous les agents grammaticaux d'une phrase (sujet, verbe, COD/COI ...), tout en repérant les incises et subordonnées. Bien évidemment, face à  l'ampleur de la tache, le peu de temps dont nous disposions et notre maitrise limitée de la technologie nous ont amenés à envisager une autre solution.

\subsection{Mise en pratique : Java}
Nous avons donc suivi les conseils de notre enseignant référent Alexande Pauchet, et nous sommes tournés vers une technologie que nous connaissions bien mieux : le Java.
\paragraph{}La logique métier a été codée de manière très simple, selon les principes vus en cours d'Algorithmique et de Programmation Avancée : une classe pour chaque Type Abstrait de Données, et une pour l'Intelligence Artificielle.
\paragraph{}Concernant l'interface, la première phase du développement a consisté à simplement faire une classe pour récupérer le texte entré en console puis afficher une réponse. En effet, nous souhaitions être sûrs que, même si l'interface n'était pas réalisée dans les temps ou ne fonctionnait pas bien, nous aurions tout de même la possibilité d'afficher le dialogue via la console. 
Pour ce dialogue console, nous avons d'abord voulu utiliser un Scanner, comme nous l'avions fait dans notre projet de Programmation Avancée au semestre 6 pour ensuite y préférer un BufferedReader qui nous a été conseillé et, après test, s'est avéré mieux fonctionner.

Nous avons ensuite pu passer à la réalisation de l'interface en elle-même, dont Marie s'est chargée. 
\paragraph{Marie : }Ainsi, j'ai souhaité utiliser eclipse et son outil de création d'interface, WindowBuilder. Comme ce logiciel nous était interdit l'année précédente, j'ai dû réapprendre à l'utiliser et j'ai aussi totalement découvert son plugin WindowBuilder. Afin de prendre en main ce "constructeur", j'ai passé du temps à chercher de la documentation à son sujet. Il est apparut que bien qu'étant un outil très pratique pour la visualisation et la création basique de fenêtres, il ne nous absous pas de devoir coder puisqu'en général, nous souhaitons personnaliser bien des aspects de celui-ci selon ce que nous devons réaliser. J'ai donc jonglé entre cet outil et le code afin d'obtenir une interface correspondant au mieux aux besoins de notre projet.
